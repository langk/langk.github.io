<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>docker - Docker Training</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "docker";
    var mkdocs_page_input_path = "docker-intro-philipp.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Docker Training</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">docker</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#hands-on-with-docker-running-and-interacting-with-prebuild-images">Hands on with Docker - Running and interacting with prebuild images</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#first-steps-with-the-docker-command">First steps with the docker command</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Docker Training</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>docker</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="hands-on-with-docker-running-and-interacting-with-prebuild-images">Hands on with Docker - Running and interacting with prebuild images</h1>
<p>A successful Docker installation runs in the background out of sight of the user. At its core is the so-called Docker deamon (or dockerd) which manages different docker objects such as containers, images or volumes.
The way to interact with the Docker daemon and tell it what to do is through a command line interface (CLI) program which is called <code>docker</code>. We refer to this here as the <code>docker</code> command. 
The docker command is very powerful and it allows us to change many aspects of how Docker runs containers, manages images or creates volumes. In this first live coding session, we will be introducing the <code>docker</code> command and show how to run and interact with prebuild Docker images.</p>
<h2 id="first-steps-with-the-docker-command">First steps with the docker command</h2>
<p>You can test your Docker installation by executing the following command, which will show the version of the Docker engine:</p>
<pre><code>(host) $ docker -v
Docker version 19.03.8, build afacb8b
</code></pre>

<p>To get an idea what we can do with docker you can run the docker command without any flag:</p>
<pre><code>(host) $ docker

Usage:  docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default &quot;/Users/sinnafoch/.docker&quot;)
  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with &quot;docker context use&quot;)
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;)
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default &quot;/Users/sinnafoch/.docker/ca.pem&quot;)
      --tlscert string     Path to TLS certificate file (default &quot;/Users/sinnafoch/.docker/cert.pem&quot;)
      --tlskey string      Path to TLS key file (default &quot;/Users/sinnafoch/.docker/key.pem&quot;)
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:
  builder     Manage builds
  checkpoint  Manage checkpoints
  config      Manage Docker configs
  container   Manage containers
  context     Manage contexts
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  deploy      Deploy a new stack or update an existing stack
  diff        Inspect changes to files or directories on a container's filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export      Export a container's filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes

Run 'docker COMMAND --help' for more information on a command.
</code></pre>

<p>The docker command is organized in different sub-commands which correspond to different aspects of Docker.
As you can see docker can do lots of different things. In this introduction we will focus on the bread and butter commands to get containers up and runnning.</p>
<p>.. sidebar:: Note</p>
<pre><code>If you would like to know about the different options you can use the docker command like so to display additional help: docker COMMAND --help. For example docker run --help will only display options associated with the docker run command.
</code></pre>
<h3 id="lets-run-our-first-container-from-a-pre-built-image">Lets run our first container from a pre-built image</h3>
<p>Probably the first container every new Docker user runs is the <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">hello-world</a> container. We will also follow this tradition to execute the hello-world docker container:</p>
<pre><code>(host) $ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
0e03bdcc26d7: Pull complete
Digest: sha256:8e3114318a995a1ee497790535e7b88365222a21771ae7e53687ad76563e8e76
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
 ```

A lot is ging on when this command is executed. Luckily the Docker hello-world container does more than printing the traditional &quot;Hello&quot; message. It also provides some additional information about what just happened. As you can see from the output above when executing the command `docker run hello-world:latest` `docker`communicates with the docker deamon and requests a container of the hello-world image. The docker deamon realized that this image is not yet available on our computer, so it downloads it from the Docker Hub (usually referred to as *pulling*). The Docker daemon stores the hello-world image on the computer and creates a virtualized runtime environment (the *container*). When this container is executed it can produce some output (in case of hello-world this is the message above), which is displayed on the terminal screen.

.. sidebar:: Note

    Usually it is good practice to always specify the version of a container when running it. This ensures reproducability and the same behavior during every run. In the case of hello-world we ran the latest version. If no version number is specified, the latest version of the container is used.


### Executing commands within a container

Lets try something a bit more advanced. In the last section we saw how the hello-world container on execution displayed some text on our terminal screen before it exits back to our command prompt. This very simple container only runs for a few seconds and the only thing it does is to display the message above. However, often it is desired to change the execution of a container as it runs or run specific commands inside the container. In fact this is probably one of the most common use cases for many scientists. 

For this example we will use a more complete container based on the official ubuntu:18.04 image:

</code></pre>

<p>(host) $ docker run ubuntu:18.04 sleep 10
(host) $</p>
<pre><code>
Running the above command will download the ubuntu:18.04 image and then execute the sleep command inside a new ubuntu:18.04 container. All the sleep command does is to tell the container to wait for 10 seconds until it exists. This addmittedly very simple command should illustrate an important point: You can basically run any program from inside your container as long as it is installed in it.

Here are some additional exampes with the ubuntu:18.04 container.

Show the OS version installed in the container:

</code></pre>

<p>(host) $ docker run ubuntu:18.04 cat /etc/os-release
NAME="Ubuntu"
VERSION="18.04.3 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.3 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic</p>
<pre><code>List the content of the / directory in the container:

</code></pre>

<p>(host) $ docker run ubuntu:18.04 ls
bin
boot
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var</p>
<pre><code>
Use apt-get to display ASCII cows:

</code></pre>

<p>(host) $ docker run ubuntu:18.04 apt-get moo
                 (__)
                 (oo)
           /------\/
          / |    ||
         *  /---/\
            ~~   ~~
..."Have you mooed today?"...</p>
<pre><code>
### Working inside a container:


You may ask yourself now how it would work if you wanted to run multiple commands inside your container or how you could prevent your container from exiting immediately after execution of a command. This can be done by providing the `-i -t`flags (usually used as `-it`). 

Lets get inside an ubuntu container:

</code></pre>

<p>(host) $ docker run -it ubuntu:18.04
root@f11c02f856a7:/#</p>
<pre><code>
Inside our container we can do all kinds of things: Create files, install software download files from the internet etc. All of this works in a familiar ubuntu environment provided by Docker.

.. sidebar:: Note

    Changes you make in interactivte mode inside a container are restricted to the currently running container. Each docker run command will spawn a new container instance which only contains what is in the underlying Docker image.



## Managing containers and images


Once you have accumulated many images and run different containers it becomes important to manage the available images and running (or stopped) containers. The docker command also comes to the rescue here:

To list all running containers you can execute `docker container ls`. If you have no currently running containers the output from this command will be an empty list. Here is an example showing how the output changes:

</code></pre>

<p>(host) $ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
$ docker run -d ubuntu:18.04 sleep 30
36f65c44b177bb23c5e4ffb9f891b85353436b824c5bcfba1b38080e29a47fe8
(host) $ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
36f65c44b177        ubuntu:18.04        "sleep 30"          4 seconds ago       Up 2 seconds                            intelligent_lewin
(host) $</p>
<pre><code>
As you can see the first call of `docker container ls` shows that there is currently no running containers. When we run the sleep command inside an ubuntu container and then look at the output of `docker container ls` again we get information about it.

.. sidebar:: Note

    The -d flag in the docker run command sends a container to the background so that it continues runnning and we can continue to work in our terminal. -d is short for detach. The output of the container is detached from the current terminal.

We can also list all containers regardless if there are currently running or not.

</code></pre>

<p>(host) $ docker container ls -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES
36f65c44b177        ubuntu:18.04        "sleep 30"               9 minutes ago       Exited (0) 8 minutes ago                             intelligent_lewin
52c9c0117a2f        hello-world         "/hello"                 16 minutes ago      Exited (0) 16 minutes ago                            tender_germain
22c3563c46a5        ubuntu:18.04        "/bin/bash"              About an hour ago   Exited (0) About an hour ago                         happy_burnell
3a2e784dd2f8        hello-world         "/hello"                 About an hour ago   Exited (0) About an hour ago                         loving_hermann</p>
<pre><code>
### Restarting stopped containers

From the above command we see that all containers we ran are still there, they have not disappeared they have just stopped running. Docker by standard saves a copy of each executed container. Consequently the changes we made inside the ubuntu container previously should still be there somewhere. We just have to find the correct container and execute it again to get to our files again. The docker command has an option to restart stopped containers. 

For example if you would like to get inside the an existing ubuntu container we could run:

</code></pre>

<p>(host) $ docker start -ia 36f65c44b177</p>
<pre><code>
Docker conveniently names each container with a random but more humanly readable name which can be used instead of the complicated container ID. The above command is thus equivalent with:

</code></pre>

<p>(host) $ docker start -ia happy_burnell</p>
<pre><code>
.. sidebar:: Note

    Note that -ia is the equivalent to -it in docker start.

Similar to starting stopped containers you can also stop running containers with `docker stop`.


To list all images off which you can base containers you can use the `docker images` command:

</code></pre>

<p>(host) $ docker images
REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE
hello-world                       latest              bf756fb1ae65        3 months ago        13.3kB
ubuntu                            18.04               ccc6e87d482b        3 months ago        64.2MB
(host) $</p>
<pre><code>
This gives an overview of your downloaded images as well as intermediate images which are created when you build them yourself. Each image has an ID consiting of letters and numbers. This ID can be used to remove an image. For example you could run `docker image rm bf756fb1ae65` to remove the hello-world image from your computer. Image removal only works when there are no containers relying on that image.

## Sharing data with the host system

Often, it is desired to share data from the host computer with the container. For example you may want to analyse files you created inside your container or you may want to copy files from inside your container to your computer. Docker provides two ways to do this: Docker volumes and bind-mounting whole directories. We will quickly who both here:

### Docker volumes

A Docker volume is a special place in the hosts file-system which is used to store data generated by the runnning container. Docker will automatically create a volume for each running container. The idea behind this is to keep the during runtime created files seperated from the image to make it easy to transition to different image versions. In this case Docker will create a new container of the updated image but your local files will stay unchanged. 
Apart from these automatically created volumes, we can also create one manually:

</code></pre>

<p>(host) $ docker volume create my_data
my_data</p>
<pre><code>
With `docker volume ls` we can list our current volumes:

</code></pre>

<p>(host) $ docker volume ls
DRIVER              VOLUME NAME
local               my_data</p>
<pre><code>
.. sidebar:: Note

    Volumes are especially handy to share data between more complex setups with multiple containers. e.g. databases


After we created the volume we can tell Docker to make it available when a container is run. This is done like this:

</code></pre>

<p>(host) $ docker run -it -v my_data:/data ubuntu:18.04</p>
<pre><code>As you can see we introduced a new command line flag `-v`. One could say the flag works like this: Take the volume with the name on the left side of the colon and include it as new directory on the right side of the colon inside the container. Here the right side can be a longer path as well, it is however important that the path is absolute (starts with / ).
Now, inside the container we can move to the bound volume and create some dummy data:

</code></pre>

<p>root@eca8560a6bd1:/# cd /data
root@eca8560a6bd1:/data# ls
root@eca8560a6bd1:/data# mkdir testdata
root@eca8560a6bd1:/data# touch file_inside_the_container
root@eca8560a6bd1:/data# ls
file_inside_the_container  testdata
root@eca8560a6bd1:/data# exit</p>
<pre><code>We can now run a completely different container, have it include the same volume and then list its contents:

</code></pre>

<p>(host) $ docker run --rm -it -v my_data:/data alpine:3.11
Unable to find image 'alpine:3.11' locally
3.11: Pulling from library/alpine
cbdbe7a5bc2a: Pull complete
Digest: sha256:9a839e63dad54c3a6d1834e29692c8492d93f90c59c978c1ed79109ea4fb9a54
Status: Downloaded newer image for alpine:3.11
/ # cd /data
/data # ls
file_inside_the_container  testdata
/data #</p>
<pre><code>
Very nice. The volume is now part of both containers. We could now make additional changes to the files and then restart the Ubuntu container to look at the changed files.

To remove a volume you can run:

</code></pre>

<p>(host) $ docker volume rm my_data
my_data</p>
<pre><code>

### Mounting directories

While volumes are very helpful when sharing data between containers, it is often also necessary to copy files between the host and the container. It is possible to find your created volumes (they are just folders on your host computer), but they are usally stored in place we don't normally access (e.g. on Linux Docker stores them in `/usr/lib/docker/volumes`). We could navigate to this directory and copy data frame there.
However, you can also bin-mount directories directly to your containers again using the `-v`flag in `docker run`:

</code></pre>

<p>(host) $ docker run -v $(pwd):/data ubuntu</p>
<pre><code>
This command will mount the current working directory on your host to the `/data` folder inside the ubuntu container. You can now make changes to that folder inside your container and the changes will translate to the folder on the host computer.

We will now create a `testfile` in the current directory. Then we will start a container mounting this directory. Inside the container we will create another `testfile`. All changes persist also when we exit the container:

</code></pre>

<p>(host) $ ls
docker-intro.md
(host) $ pwd
/Users/sinnafoch/Dropbox/Philipp/docker-intro
(host) $ touch testfile
(host) $ ls
testfile
(host) $ docker run -it --rm -v $(pwd):/data ubuntu:18.04
root@a0f138701fc5:/# cd /data
root@a0f138701fc5:/data# ls
testfile
root@a0f138701fc5:/data# touch another_testfile
root@a0f138701fc5:/data# exit
exit
(host) $ ls
testfile
(host) $
```</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
